Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    RIGHT_OP
    DO
    EXCLAIM
    SHORT
    RETURN
    RIGHT_ASSIGN
    DEFAULT
    VOID
    CHAR
    OPEN_CURLY
    WHILE
    COLON
    STATIC
    DIV_ASSIGN
    MUL
    EXTERN
    CONST
    SIZEOF
    CLOSE_SQUARE
    DOT
    DIVIDE
    CASE
    OP_OP
    LE_OP
    MUL_ASSIGN
    SEMICOLON
    REGISTER
    UNSIGNED
    LONG
    MINUS
    DEC_OP
    SWITCH
    AND_ASSIGN
    COMMA
    CLOSE_CURLY
    PTR_OP
    ADD_ASIGN
    GREATER_THAN
    ELLIPSIS
    PLUS
    TYPEDEF
    XOR
    GOTO
    FOR
    UNION
    AUTO
    ENUM
    ELSE
    AND_OP
    GE_OP
    LEFT_OP
    OPEN_SQUARE
    IF
    SUB_ASSIGN
    MOD_ASSIGN
    SCONST
    COND_OP
    STRUCT
    XOR_ASSIGN
    INT
    DOUBLE
    FLOAT
    OR_ASSIGN
    AND
    SIGNED
    BREAK
    CONTINUE
    VOLATILE
    LESS_THAN
    NOT
    LEFT_ASSIGN
    MOD
    INC_OP
    OR
    NE_OP
    EQ_OP

Grammar

Rule 0     S' -> statement
Rule 1     statement -> ID EQUAL expression
Rule 2     statement -> expression
Rule 3     expression -> OPEN_PAR expression CLOSE_PAR
Rule 4     expression -> CONSTANT
Rule 5     expression -> ID

Terminals, with rules where they appear

ADD_ASIGN            : 
AND                  : 
AND_ASSIGN           : 
AND_OP               : 
AUTO                 : 
BREAK                : 
CASE                 : 
CHAR                 : 
CLOSE_CURLY          : 
CLOSE_PAR            : 3
CLOSE_SQUARE         : 
COLON                : 
COMMA                : 
COND_OP              : 
CONST                : 
CONSTANT             : 4
CONTINUE             : 
DEC_OP               : 
DEFAULT              : 
DIVIDE               : 
DIV_ASSIGN           : 
DO                   : 
DOT                  : 
DOUBLE               : 
ELLIPSIS             : 
ELSE                 : 
ENUM                 : 
EQUAL                : 1
EQ_OP                : 
EXCLAIM              : 
EXTERN               : 
FLOAT                : 
FOR                  : 
GE_OP                : 
GOTO                 : 
GREATER_THAN         : 
ID                   : 1 5
IF                   : 
INC_OP               : 
INT                  : 
LEFT_ASSIGN          : 
LEFT_OP              : 
LESS_THAN            : 
LE_OP                : 
LONG                 : 
MINUS                : 
MOD                  : 
MOD_ASSIGN           : 
MUL                  : 
MUL_ASSIGN           : 
NE_OP                : 
NOT                  : 
OPEN_CURLY           : 
OPEN_PAR             : 3
OPEN_SQUARE          : 
OP_OP                : 
OR                   : 
OR_ASSIGN            : 
PLUS                 : 
PTR_OP               : 
REGISTER             : 
RETURN               : 
RIGHT_ASSIGN         : 
RIGHT_OP             : 
SCONST               : 
SEMICOLON            : 
SHORT                : 
SIGNED               : 
SIZEOF               : 
STATIC               : 
STRUCT               : 
SUB_ASSIGN           : 
SWITCH               : 
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 
XOR                  : 
XOR_ASSIGN           : 
error                : 

Nonterminals, with rules where they appear

expression           : 1 2 3
statement            : 0

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . ID EQUAL expression
    (2) statement -> . expression
    (3) expression -> . OPEN_PAR expression CLOSE_PAR
    (4) expression -> . CONSTANT
    (5) expression -> . ID

    ID              shift and go to state 5
    OPEN_PAR        shift and go to state 1
    CONSTANT        shift and go to state 2

    expression                     shift and go to state 4
    statement                      shift and go to state 3

state 1

    (3) expression -> OPEN_PAR . expression CLOSE_PAR
    (3) expression -> . OPEN_PAR expression CLOSE_PAR
    (4) expression -> . CONSTANT
    (5) expression -> . ID

    OPEN_PAR        shift and go to state 1
    CONSTANT        shift and go to state 2
    ID              shift and go to state 7

    expression                     shift and go to state 6

state 2

    (4) expression -> CONSTANT .

    $end            reduce using rule 4 (expression -> CONSTANT .)
    CLOSE_PAR       reduce using rule 4 (expression -> CONSTANT .)


state 3

    (0) S' -> statement .



state 4

    (2) statement -> expression .

    $end            reduce using rule 2 (statement -> expression .)


state 5

    (1) statement -> ID . EQUAL expression
    (5) expression -> ID .

    EQUAL           shift and go to state 8
    $end            reduce using rule 5 (expression -> ID .)


state 6

    (3) expression -> OPEN_PAR expression . CLOSE_PAR

    CLOSE_PAR       shift and go to state 9


state 7

    (5) expression -> ID .

    $end            reduce using rule 5 (expression -> ID .)
    CLOSE_PAR       reduce using rule 5 (expression -> ID .)


state 8

    (1) statement -> ID EQUAL . expression
    (3) expression -> . OPEN_PAR expression CLOSE_PAR
    (4) expression -> . CONSTANT
    (5) expression -> . ID

    OPEN_PAR        shift and go to state 1
    CONSTANT        shift and go to state 2
    ID              shift and go to state 7

    expression                     shift and go to state 10

state 9

    (3) expression -> OPEN_PAR expression CLOSE_PAR .

    $end            reduce using rule 3 (expression -> OPEN_PAR expression CLOSE_PAR .)
    CLOSE_PAR       reduce using rule 3 (expression -> OPEN_PAR expression CLOSE_PAR .)


state 10

    (1) statement -> ID EQUAL expression .

    $end            reduce using rule 1 (statement -> ID EQUAL expression .)

